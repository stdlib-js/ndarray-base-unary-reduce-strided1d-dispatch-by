{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/index_of_types.js","../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isBoolean } from '@stdlib/assert-is-boolean';\nimport { primitives as isIntegerArray } from '@stdlib/assert-is-integer-array';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport normalizeIndices from '@stdlib/ndarray-base-to-unique-normalized-indices';\nimport join from '@stdlib/array-base-join';\nimport contains from '@stdlib/array-base-assert-contains';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {NonNegativeInteger} ndims - number of input ndarray dimensions\n* @param {Array} dtypes - list of supported output data types\n* @param {Options} options - function options\n* @param {boolean} [options.keepdims] - boolean indicating whether the reduced dimensions should be included in the returned ndarray as singleton dimensions\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @param {string} [options.dtype] - output ndarray data type\n* @returns {(Error|null)} null or an error object\n*\n* @example\n* var dtypes = [ 'float64', 'float32', 'generic' ];\n*\n* var opts = {};\n* var options = {\n*     'keepdims': true\n* };\n* var err = validate( opts, 3, dtypes, options );\n* if ( err ) {\n*     throw err;\n* }\n*/\nfunction validate( opts, ndims, dtypes, options ) {\n\tvar tmp;\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'keepdims' ) ) {\n\t\topts.keepdims = options.keepdims;\n\t\tif ( !isBoolean( opts.keepdims ) ) {\n\t\t\treturn new TypeError( format( 'null2o', 'keepdims', opts.keepdims ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'dims' ) ) {\n\t\topts.dims = options.dims;\n\t\tif ( !isIntegerArray( opts.dims ) && !isEmptyCollection( opts.dims ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be an array of integers. Option: `%s`.', 'dims', opts.dims ) );\n\t\t}\n\t\ttmp = normalizeIndices( opts.dims, ndims-1 );\n\t\tif ( tmp === null ) {\n\t\t\treturn new RangeError( format( 'invalid option. `%s` option contains an out-of-bounds dimension index. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\tif ( tmp.length !== opts.dims.length ) {\n\t\t\treturn new Error( format( 'invalid option. `%s` option contains duplicate indices. Option: [%s].', 'dims', join( opts.dims, ',' ) ) );\n\t\t}\n\t\topts.dims = tmp;\n\t}\n\tif ( hasOwnProp( options, 'dtype' ) ) {\n\t\topts.dtype = options.dtype;\n\t\tif ( !contains( dtypes, opts.dtype ) ) {\n\t\t\treturn new TypeError( format( 'null4S', 'dtype', join( dtypes, '\", \"' ), opts.dtype ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Returns the first row index at which a given one-dimensional array of types can be found in a two-dimensional reference array of types (or `-1` if not found).\n*\n* ## Notes\n*\n* -   The intended use case for this function is for type dispatch (i.e., given a set of array data types, find a matching interface according the interface's accepted array data types).\n* -   The function assumes that `x` is stored in row-major order.\n* -   The function assumes that the number of indexed elements in `y` equals the number of columns in `x`.\n* -   The function returns a row index. To convert to a linear index, multiply `strideX1` by the return value.\n*\n* @private\n* @param {NonNegativeInteger} N - number of rows in `x` (size of first dimension)\n* @param {NonNegativeInteger} M - number of columns in `x` (size of second dimension)\n* @param {ArrayLikeObject} x - input two-dimensional reference array\n* @param {integer} strideX1 - `x` stride length along first dimension\n* @param {integer} strideX2 - `x` stride length along second dimension\n* @param {NonNegativeInteger} offsetX - `x` starting index\n* @param {ArrayLikeObject} y - search array\n* @param {integer} strideY - `y` stride length\n* @param {NonNegativeInteger} offsetY - `y` starting index\n* @returns {integer} row index (if found) and `-1` otherwise\n*\n* @example\n* // Define a reference array to search:\n* var types = [\n*     'float64', 'float64', 'float64',\n*     'float32', 'float32', 'float32',\n*     'uint32', 'uint32', 'float64',\n*     'int32', 'int32', 'float64',\n*     'uint16', 'uint16', 'float64',\n*     'int16', 'int16', 'float64',\n*     'uint8', 'uint8', 'float64',\n*     'int8', 'int8', 'float64'\n* ];\n*\n* // Define reference array dimensions:\n* var N = 8; // rows\n* var M = 3; // columns\n*\n* // Define a search array:\n* y1 = [\n*     'float32', 'float32', 'float32',\n* ];\n*\n* // Find the list of types:\n* var r1 = indexOfTypes( N, M, types, M, 1, 0, y1, 1, 0 );\n* // returns 1\n*\n// Define a search array:\n* y2 = [\n*     'float32', 'float32', 'float64',\n* ];\n*\n* // Find the list of types:\n* var r2 = indexOfTypes( N, M, types, M, 1, 0, y2, 1, 0 );\n* // returns -1\n*/\nfunction indexOfTypes( N, M, x, strideX1, strideX2, offsetX, y, strideY, offsetY ) { // eslint-disable-line max-len\n\tvar ix;\n\tvar iy;\n\tvar i;\n\tvar j;\n\n\t// Search for the first row which matches `y`...\n\tix = offsetX;\n\tfor ( i = 0; i < N; i++ ) {\n\t\tiy = offsetY;\n\t\tfor ( j = 0; j < M; j++ ) {\n\t\t\tif ( x[ ix+(j*strideX2) ] !== y[ iy ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tiy += strideY;\n\t\t}\n\t\t// If we successfully iterated over all columns, then that means we've found a match...\n\t\tif ( j === M ) {\n\t\t\treturn i;\n\t\t}\n\t\tix += strideX1;\n\t}\n\treturn -1;\n}\n\n\n// EXPORTS //\n\nexport default indexOfTypes;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable no-restricted-syntax, no-invalid-this, max-lines, max-len */\n\n'use strict';\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport hasProp from '@stdlib/assert-has-property';\nimport isndarrayLike from '@stdlib/assert-is-ndarray-like';\nimport isObject from '@stdlib/assert-is-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport isCollection from '@stdlib/assert-is-collection';\nimport isEmptyCollection from '@stdlib/assert-is-empty-collection';\nimport isFunctionArray from '@stdlib/assert-is-function-array';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport isOutputDataTypePolicy from '@stdlib/ndarray-base-assert-is-output-data-type-policy';\nimport isInputCastingPolicy from '@stdlib/ndarray-base-assert-is-input-casting-policy';\nimport contains from '@stdlib/array-base-assert-contains';\nimport unaryReduceStrided1dBy from '@stdlib/ndarray-base-unary-reduce-strided1d-by';\nimport unaryOutputDataType from '@stdlib/ndarray-base-unary-output-dtype';\nimport unaryInputCastingDataType from '@stdlib/ndarray-base-unary-input-casting-dtype';\nimport resolveEnum from '@stdlib/ndarray-base-dtype-resolve-enum';\nimport dtypes2enums from '@stdlib/ndarray-base-dtypes2enums';\nimport spreadDimensions from '@stdlib/ndarray-base-spread-dimensions';\nimport getShape from '@stdlib/ndarray-shape'; // note: non-base accessor is intentional due to input ndarrays originating in userland\nimport ndims from '@stdlib/ndarray-ndims';\nimport getDType from '@stdlib/ndarray-base-dtype';\nimport getOrder from '@stdlib/ndarray-base-order';\nimport assign from '@stdlib/ndarray-base-assign';\nimport baseEmpty from '@stdlib/ndarray-base-empty';\nimport empty from '@stdlib/ndarray-empty';\nimport indicesComplement from '@stdlib/array-base-indices-complement';\nimport takeIndexed from '@stdlib/array-base-take-indexed';\nimport zeroTo from '@stdlib/array-base-zero-to';\nimport join from '@stdlib/array-base-join';\nimport copy from '@stdlib/array-base-copy';\nimport insertAt from '@stdlib/array-base-insert-at';\nimport everyBy from '@stdlib/array-base-every-by';\nimport objectAssign from '@stdlib/object-assign';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport defaults from './defaults.json';\nimport validate from './validate.js';\nimport indexOfTypes from './index_of_types.js';\n\n\n// MAIN //\n\n/**\n* Constructor for performing a reduction on an input ndarray according to a callback function.\n*\n* @constructor\n* @param {Object} table - dispatch table\n* @param {Function} table.default - default strided reduction function\n* @param {StringArray} [table.types=[]] - one-dimensional list of ndarray data types describing specialized input ndarray argument signatures\n* @param {ArrayLikeObject<Function>} [table.fcns=[]] - list of strided reduction functions which are specific to specialized input ndarray argument signatures\n* @param {ArrayLikeObject<StringArray>} idtypes - list containing lists of supported input data types for each ndarray argument\n* @param {StringArray} odtypes - list of supported output data types\n* @param {Object} policies - policies\n* @param {string} policies.output - output data type policy\n* @param {string} policies.casting - input ndarray casting policy\n* @throws {TypeError} first argument must be an object having valid properties\n* @throws {TypeError} second argument must be an array containing arrays of supported data types\n* @throws {TypeError} third argument must be an array of supported data types\n* @throws {TypeError} fourth argument must be an object having supported policies\n* @throws {Error} first argument must be an object having valid properties\n* @returns {UnaryStrided1dDispatchBy} instance\n*\n* @example\n* import base from '@stdlib/stats-base-ndarray-max-by';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'same',\n*     'casting': 'none'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var maxBy = new UnaryStrided1dDispatchBy( table, [ idt ], odt, policies );\n*\n* var xbuf = [ -1.0, 2.0, -3.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* function clbk( v ) {\n*     return v * 2.0;\n* }\n*\n* var y = maxBy.apply( x, clbk );\n* // returns <ndarray>\n*\n* var v = y.get();\n* // returns 4.0\n*/\nfunction UnaryStrided1dDispatchBy( table, idtypes, odtypes, policies ) {\n\tvar dt;\n\tvar i;\n\tif ( !( this instanceof UnaryStrided1dDispatchBy ) ) {\n\t\treturn new UnaryStrided1dDispatchBy( table, idtypes, odtypes, policies );\n\t}\n\tif ( !isObject( table ) ) {\n\t\tthrow new TypeError( format( 'null3L', table ) );\n\t}\n\tif ( !isFunction( table.default ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"default\" property and an associated method.' ) );\n\t}\n\tif ( hasProp( table, 'types' ) && !isCollection( table.types ) && !isEmptyCollection( table.types ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"types\" property whose associated value is an array-like object.' ) );\n\t}\n\tif ( hasProp( table, 'fcns' ) && !isFunctionArray( table.fcns ) && !isEmptyCollection( table.fcns ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must be an object having a \"fcns\" property whose associated value is an array-like object containing functions.' ) );\n\t}\n\tif ( !isCollection( idtypes ) ) {\n\t\tthrow new TypeError( format( 'null2y', idtypes ) );\n\t}\n\tfor ( i = 0; i < idtypes.length; i++ ) {\n\t\tdt = idtypes[ i ];\n\t\tif (\n\t\t\t!isCollection( dt ) ||\n\t\t\tdt.length < 1 ||\n\t\t\t!everyBy( dt, isDataType )\n\t\t) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Second argument must contain arrays of data types. Value: `%s`.', idtypes ) );\n\t\t}\n\t}\n\tif (\n\t\t!isCollection( odtypes ) ||\n\t\todtypes.length < 1 ||\n\t\t!everyBy( odtypes, isDataType )\n\t) {\n\t\tthrow new TypeError( format( 'invalid argument. Third argument must be an array of data types. Value: `%s`.', odtypes ) );\n\t}\n\tif ( !isObject( policies ) ) {\n\t\tthrow new TypeError( format( 'null43', policies ) );\n\t}\n\tif ( !isOutputDataTypePolicy( policies.output ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported output data type policy. Value: `%s`.', policies.output ) );\n\t}\n\tif ( !isInputCastingPolicy( policies.casting ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. Fourth argument must be an object having a supported casting policy. Value: `%s`.', policies.casting ) );\n\t}\n\tthis._table = {\n\t\t'default': table.default,\n\t\t'types': ( table.types ) ? dtypes2enums( table.types ) : [], // note: convert to enums (i.e., integers) to ensure faster comparisons\n\t\t'fcns': ( table.fcns ) ? copy( table.fcns ) : []\n\t};\n\tif ( this._table.types.length !== this._table.fcns.length ) {\n\t\tthrow new Error( 'invalid argument. First argument specifies an unexpected number of types. An input ndarray data type must be specified for each provided strided function.' );\n\t}\n\tthis._idtypes = idtypes;\n\tthis._odtypes = odtypes;\n\tthis._policies = {\n\t\t'output': policies.output,\n\t\t'casting': policies.casting\n\t};\n\treturn this;\n}\n\n/**\n* Performs a reduction on a provided input ndarray according to a callback function.\n*\n* @name apply\n* @memberof UnaryStrided1dDispatchBy.prototype\n* @type {Function}\n* @param {ndarrayLike} x - input ndarray\n* @param {...ndarrayLike} [args] - additional ndarray arguments\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @param {boolean} [options.keepdims=false] - boolean indicating whether the reduced dimensions should be included in the returned ndarray as singleton dimensions\n* @param {string} [options.dtype] - output ndarray data type\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback function execution context\n* @throws {TypeError} first argument must be an ndarray-like object\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} callback argument must be a function\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarray} output ndarray\n*\n* @example\n* import base from '@stdlib/stats-base-ndarray-max-by';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'same',\n*     'casting': 'none'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var maxBy = new UnaryStrided1dDispatchBy( table, [ idt ], odt, policies );\n*\n* var xbuf = [ -1.0, 2.0, -3.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* function clbk( v ) {\n*     return v * 2.0;\n* }\n*\n* var y = maxBy.apply( x, clbk );\n* // returns <ndarray>\n*\n* var v = y.get();\n* // returns 4.0\n*/\nsetReadOnly( UnaryStrided1dDispatchBy.prototype, 'apply', function apply( x ) {\n\tvar thisArg;\n\tvar options;\n\tvar dtypes;\n\tvar nargs;\n\tvar clbk;\n\tvar args;\n\tvar opts;\n\tvar err;\n\tvar idx;\n\tvar shx;\n\tvar shy;\n\tvar arr;\n\tvar tmp;\n\tvar xdt;\n\tvar ydt;\n\tvar flg;\n\tvar dt;\n\tvar f;\n\tvar N;\n\tvar y;\n\tvar i;\n\n\tnargs = arguments.length;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'null5t', x ) );\n\t}\n\txdt = getDType( x );\n\tif ( !contains( this._idtypes[ 0 ], xdt ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 0 ], '\", \"' ), xdt ) );\n\t}\n\targs = [ x ];\n\tfor ( i = 1; i < nargs; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tif ( !isndarrayLike( arr ) ) {\n\t\t\tbreak;\n\t\t}\n\t\tdt = getDType( arr );\n\t\tif ( !contains( this._idtypes[ i ], dt ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument %d must have one of the following data types: \"%s\". Data type: `%s`.', i, join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t\t// Note: we don't type promote additional ndarray arguments, as they are passed as scalars to the underlying strided reduction function...\n\t\targs.push( arr );\n\t}\n\t// Check whether we found a non-options argument which was not an ndarray...\n\tif ( i < nargs-3 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Argument %d must be an ndarray-like object. Value: `%s`.', i, arguments[ i ] ) );\n\t}\n\t// Case: ( ... )\n\tif ( i === nargs ) {\n\t\tthrow new TypeError( format( 'null2b', arguments[ nargs-1 ] ) );\n\t}\n\t// Case: ( ..., options, clbk, thisArg )\n\tif ( i === nargs-3 ) {\n\t\tflg = true;\n\t\toptions = arguments[ nargs-3 ];\n\t\tclbk = arguments[ nargs-2 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2b', clbk ) );\n\t\t}\n\t\tthisArg = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., clbk )\n\telse if ( i === nargs-1 ) {\n\t\tclbk = arguments[ nargs-1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2b', clbk ) );\n\t\t}\n\t}\n\t// Case: ( ..., clbk, thisArg )\n\telse if ( isFunction( arguments[ nargs-2 ] ) ) {\n\t\tclbk = arguments[ nargs-2 ];\n\t\tthisArg = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., options, clbk )\n\telse if ( isFunction( arguments[ nargs-1 ] ) ) {\n\t\tflg = true;\n\t\toptions = arguments[ nargs-2 ];\n\t\tclbk = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., ???, ??? )\n\telse {\n\t\tthrow new TypeError( format( 'null2b', arguments[ nargs-2 ] ) );\n\t}\n\tshx = getShape( x );\n\tN = shx.length;\n\n\topts = objectAssign( {}, defaults );\n\tif ( flg ) {\n\t\terr = validate( opts, N, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t// When a list of dimensions is not provided, reduce the entire input ndarray across all dimensions...\n\tif ( opts.dims === null ) {\n\t\topts.dims = zeroTo( N );\n\t}\n\t// Resolve the list of non-reduced dimensions:\n\tidx = indicesComplement( N, opts.dims );\n\n\t// Resolve the output array shape:\n\tshy = takeIndexed( shx, idx );\n\n\t// Initialize an output array whose shape matches that of the non-reduced dimensions and which has the same memory layout as the input ndarray:\n\tydt = opts.dtype || unaryOutputDataType( xdt, this._policies.output );\n\ty = empty( shy, {\n\t\t'dtype': ydt,\n\t\t'order': getOrder( x )\n\t});\n\n\t// Determine whether we need to cast the input ndarray...\n\tdt = unaryInputCastingDataType( xdt, ydt, this._policies.casting );\n\tif ( xdt !== dt ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, shx, getOrder( x ) );\n\t\tassign( [ x, tmp ] );\n\t\targs[ 0 ] = tmp;\n\t\txdt = dt;\n\t}\n\t// Resolve the lower-level strided function satisfying the input ndarray data type:\n\tdtypes = [ resolveEnum( xdt ) ];\n\ti = indexOfTypes( this._table.fcns.length, 1, this._table.types, 1, 1, 0, dtypes, 1, 0 );\n\tif ( i >= 0 ) {\n\t\tf = this._table.fcns[ i ];\n\t} else {\n\t\tf = this._table.default;\n\t}\n\t// Perform the reduction:\n\tunaryReduceStrided1dBy( f, insertAt( args, 1, y ), opts.dims, clbk, thisArg );\n\n\t// Check whether we need to reinsert singleton dimensions which can be useful for broadcasting the returned output array to the shape of the original input array...\n\tif ( opts.keepdims ) {\n\t\ty = spreadDimensions( N, y, idx );\n\t}\n\treturn y;\n});\n\n/**\n* Performs a reduction on a provided input ndarray according to a callback function and assigns results to a provided output ndarray.\n*\n* @name assign\n* @memberof UnaryStrided1dDispatchBy.prototype\n* @type {Function}\n* @param {ndarrayLike} x - input ndarray\n* @param {...ndarrayLike} [args] - additional ndarray arguments\n* @param {ndarrayLike} out - output ndarray\n* @param {Options} [options] - function options\n* @param {IntegerArray} [options.dims] - list of dimensions over which to perform a reduction\n* @param {Function} clbk - callback function\n* @param {*} [thisArg] - callback function execution context\n* @throws {TypeError} first argument must be an ndarray\n* @throws {TypeError} first argument must have a supported data type\n* @throws {TypeError} output argument must be an ndarray\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} callback argument must be a function\n* @throws {RangeError} dimension indices must not exceed input ndarray bounds\n* @throws {RangeError} number of dimension indices must not exceed the number of input ndarray dimensions\n* @throws {Error} must provide valid options\n* @returns {ndarrayLike} output ndarray\n*\n* @example\n* import base from '@stdlib/stats-base-ndarray-max-by';\n* import dtypes from '@stdlib/ndarray-dtypes';\n* import ndarray from '@stdlib/ndarray-base-ctor';\n*\n* var idt = dtypes( 'real_and_generic' );\n* var odt = idt;\n* var policies = {\n*     'output': 'same',\n*     'casting': 'none'\n* };\n*\n* var table = {\n*     'default': base\n* };\n* var maxBy = new UnaryStrided1dDispatchBy( table, [ idt ], odt, policies );\n*\n* var xbuf = [ -1.0, 2.0, -3.0 ];\n* var x = new ndarray( 'generic', xbuf, [ xbuf.length ], [ 1 ], 0, 'row-major' );\n*\n* var ybuf = [ 0.0 ];\n* var y = new ndarray( 'generic', ybuf, [], [ 0 ], 0, 'row-major' );\n*\n* function clbk( v ) {\n*     return v * 2.0;\n* }\n*\n* var out = maxBy.assign( x, y, clbk );\n* // returns <ndarray>\n*\n* var v = out.get();\n* // returns 4.0\n*\n* var bool = ( out === y );\n* // returns true\n*/\nsetReadOnly( UnaryStrided1dDispatchBy.prototype, 'assign', function assign( x ) {\n\tvar thisArg;\n\tvar options;\n\tvar dtypes;\n\tvar nargs;\n\tvar clbk;\n\tvar opts;\n\tvar args;\n\tvar arr;\n\tvar err;\n\tvar flg;\n\tvar xdt;\n\tvar tmp;\n\tvar dt;\n\tvar N;\n\tvar f;\n\tvar y;\n\tvar i;\n\n\tnargs = arguments.length;\n\tif ( !isndarrayLike( x ) ) {\n\t\tthrow new TypeError( format( 'null5t', x ) );\n\t}\n\t// Validate the input ndarray data type in order to maintain similar behavior to `apply` above...\n\txdt = getDType( x );\n\tif ( !contains( this._idtypes[ 0 ], xdt ) ) {\n\t\tthrow new TypeError( format( 'invalid argument. First argument must have one of the following data types: \"%s\". Data type: `%s`.', join( this._idtypes[ 0 ], '\", \"' ), xdt ) );\n\t}\n\targs = [ x ];\n\n\t// Resolve additional ndarray arguments...\n\tfor ( i = 1; i < nargs; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tif ( !isndarrayLike( arr ) ) {\n\t\t\tbreak;\n\t\t}\n\t\targs.push( arr );\n\t}\n\t// Ensure that we were provided an output ndarray...\n\tif ( i < 2 ) {\n\t\tthrow new TypeError( format( 'invalid argument. Second argument must be an ndarray-like object. Value: `%s`.', arguments[ 1 ] ) );\n\t}\n\t// Case: ( ..., out )\n\tif ( i === nargs ) {\n\t\tthrow new TypeError( format( 'null2b', arguments[ nargs-1 ] ) );\n\t}\n\t// Case: ( ..., out, options, clbk, thisArg )\n\tif ( i === nargs-3 ) {\n\t\tflg = true;\n\t\toptions = arguments[ nargs-3 ];\n\t\tclbk = arguments[ nargs-2 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2b', clbk ) );\n\t\t}\n\t\tthisArg = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., out, clbk )\n\telse if ( i === nargs-1 ) {\n\t\tclbk = arguments[ nargs-1 ];\n\t\tif ( !isFunction( clbk ) ) {\n\t\t\tthrow new TypeError( format( 'null2b', clbk ) );\n\t\t}\n\t}\n\t// Case: ( ..., out, clbk, thisArg )\n\telse if ( isFunction( arguments[ nargs-2 ] ) ) {\n\t\tclbk = arguments[ nargs-2 ];\n\t\tthisArg = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., out, options, clbk )\n\telse if ( isFunction( arguments[ nargs-1 ] ) ) {\n\t\tflg = true;\n\t\toptions = arguments[ nargs-2 ];\n\t\tclbk = arguments[ nargs-1 ];\n\t}\n\t// Case: ( ..., out, ???, ??? )\n\telse {\n\t\tthrow new TypeError( format( 'null2b', arguments[ nargs-2 ] ) );\n\t}\n\t// Cache a reference to the output ndarray:\n\ty = args.pop();\n\n\t// Verify that additional ndarray arguments have expected dtypes (note: we intentionally don't validate the output ndarray dtype in order to provide an escape hatch for a user wanting to have an output ndarray having a specific dtype that `apply` does not support; note: we don't type promote additional ndarray arguments, as they are passed as scalars to the underlying strided reduction function)...\n\tfor ( i = 1; i < args.length; i++ ) {\n\t\tdt = getDType( args[ i ] );\n\t\tif ( !contains( this._idtypes[ i ], dt ) ) {\n\t\t\tthrow new TypeError( format( 'invalid argument. Argument %d must have one of the following data types: \"%s\". Data type: `%s`.', i, join( this._idtypes[ i ], '\", \"' ), dt ) );\n\t\t}\n\t}\n\t// Validate any provided options...\n\tN = ndims( x );\n\topts = objectAssign( {}, defaults );\n\tif ( flg ) {\n\t\terr = validate( opts, N, this._odtypes, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\t// When a list of dimensions is not provided, reduce the entire input array across all dimensions...\n\tif ( opts.dims === null ) {\n\t\topts.dims = zeroTo( N );\n\t}\n\t// Determine whether we need to cast the input ndarray...\n\tdt = unaryInputCastingDataType( xdt, getDType( y ), this._policies.casting );\n\tif ( xdt !== dt ) {\n\t\t// TODO: replace the following logic with a call to `ndarray/base/(?maybe-)(cast|convert|copy)` or similar utility\n\t\ttmp = baseEmpty( dt, getShape( x ), getOrder( x ) );\n\t\tassign( [ x, tmp ] );\n\t\targs[ 0 ] = tmp;\n\t\txdt = dt;\n\t}\n\t// Resolve the lower-level strided function satisfying the input ndarray data type:\n\tdtypes = [ resolveEnum( xdt ) ];\n\ti = indexOfTypes( this._table.fcns.length, 1, this._table.types, 1, 1, 0, dtypes, 1, 0 );\n\tif ( i >= 0 ) {\n\t\tf = this._table.fcns[ i ];\n\t} else {\n\t\tf = this._table.default;\n\t}\n\t// Perform the reduction:\n\tunaryReduceStrided1dBy( f, insertAt( args, 1, y ), opts.dims, clbk, thisArg ); // note: we assume that this lower-level function handles further validation of the output ndarray (e.g., expected shape, etc)\n\n\treturn y;\n});\n\n\n// EXPORTS //\n\nexport default UnaryStrided1dDispatchBy;\n"],"names":["validate","opts","ndims","dtypes","options","tmp","isObject","TypeError","format","hasOwnProp","keepdims","isBoolean","dims","isIntegerArray","isEmptyCollection","normalizeIndices","RangeError","join","length","Error","dtype","contains","indexOfTypes","N","M","x","strideX1","strideX2","offsetX","y","strideY","offsetY","ix","iy","i","j","UnaryStrided1dDispatchBy","table","idtypes","odtypes","policies","dt","this","isFunction","default","hasProp","isCollection","types","isFunctionArray","fcns","everyBy","isDataType","isOutputDataTypePolicy","output","isInputCastingPolicy","casting","_table","dtypes2enums","copy","_idtypes","_odtypes","_policies","setReadOnly","prototype","thisArg","nargs","clbk","args","err","idx","shx","shy","arr","xdt","ydt","flg","f","arguments","isndarrayLike","getDType","push","getShape","objectAssign","defaults","zeroTo","indicesComplement","takeIndexed","unaryOutputDataType","empty","order","getOrder","unaryInputCastingDataType","baseEmpty","assign","resolveEnum","unaryReduceStrided1dBy","insertAt","spreadDimensions","pop"],"mappings":";;uxHA4DA,SAASA,EAAUC,EAAMC,EAAOC,EAAQC,GACvC,IAAIC,EACJ,IAAMC,EAAUF,GACf,OAAO,IAAIG,UAAWC,EAAQ,SAAUJ,IAEzC,GAAKK,EAAYL,EAAS,cACzBH,EAAKS,SAAWN,EAAQM,UAClBC,EAAWV,EAAKS,WACrB,OAAO,IAAIH,UAAWC,EAAQ,SAAU,WAAYP,EAAKS,WAG3D,GAAKD,EAAYL,EAAS,QAAW,CAEpC,GADAH,EAAKW,KAAOR,EAAQQ,MACdC,EAAgBZ,EAAKW,QAAWE,EAAmBb,EAAKW,MAC7D,OAAO,IAAIL,UAAWC,EAAQ,0EAA2E,OAAQP,EAAKW,OAGvH,GAAa,QADbP,EAAMU,EAAkBd,EAAKW,KAAMV,EAAM,IAExC,OAAO,IAAIc,WAAYR,EAAQ,uFAAwF,OAAQS,EAAMhB,EAAKW,KAAM,OAEjJ,GAAKP,EAAIa,SAAWjB,EAAKW,KAAKM,OAC7B,OAAO,IAAIC,MAAOX,EAAQ,wEAAyE,OAAQS,EAAMhB,EAAKW,KAAM,OAE7HX,EAAKW,KAAOP,CACZ,CACD,OAAKI,EAAYL,EAAS,WACzBH,EAAKmB,MAAQhB,EAAQgB,OACfC,EAAUlB,EAAQF,EAAKmB,QACrB,IAAIb,UAAWC,EAAQ,SAAU,QAASS,EAAMd,EAAQ,QAAUF,EAAKmB,QAGzE,IACR,CCbA,SAASE,EAAcC,EAAGC,EAAGC,EAAGC,EAAUC,EAAUC,EAASC,EAAGC,EAASC,GACxE,IAAIC,EACAC,EACAC,EACAC,EAIJ,IADAH,EAAKJ,EACCM,EAAI,EAAGA,EAAIX,EAAGW,IAAM,CAEzB,IADAD,EAAKF,EACCI,EAAI,EAAGA,EAAIX,GACXC,EAAGO,EAAIG,EAAER,KAAgBE,EAAGI,GADdE,IAInBF,GAAMH,EAGP,GAAKK,IAAMX,EACV,OAAOU,EAERF,GAAMN,CACN,CACD,OAAQ,CACT,CCaA,SAASU,EAA0BC,EAAOC,EAASC,EAASC,GAC3D,IAAIC,EACAP,EACJ,KAAQQ,gBAAgBN,GACvB,OAAO,IAAIA,EAA0BC,EAAOC,EAASC,EAASC,GAE/D,IAAMlC,EAAU+B,GACf,MAAM,IAAI9B,UAAWC,EAAQ,SAAU6B,IAExC,IAAMM,EAAYN,EAAMO,SACvB,MAAM,IAAIrC,UAAWC,EAAQ,6GAE9B,GAAKqC,EAASR,EAAO,WAAcS,EAAcT,EAAMU,SAAYjC,EAAmBuB,EAAMU,OAC3F,MAAM,IAAIxC,UAAWC,EAAQ,iIAE9B,GAAKqC,EAASR,EAAO,UAAaW,EAAiBX,EAAMY,QAAWnC,EAAmBuB,EAAMY,MAC5F,MAAM,IAAI1C,UAAWC,EAAQ,qJAE9B,IAAMsC,EAAcR,GACnB,MAAM,IAAI/B,UAAWC,EAAQ,SAAU8B,IAExC,IAAMJ,EAAI,EAAGA,EAAII,EAAQpB,OAAQgB,IAEhC,GADAO,EAAKH,EAASJ,IAEZY,EAAcL,IACfA,EAAGvB,OAAS,IACXgC,EAAST,EAAIU,GAEd,MAAM,IAAI5C,UAAWC,EAAQ,oFAAqF8B,IAGpH,IACEQ,EAAcP,IACfA,EAAQrB,OAAS,IAChBgC,EAASX,EAASY,GAEnB,MAAM,IAAI5C,UAAWC,EAAQ,gFAAiF+B,IAE/G,IAAMjC,EAAUkC,GACf,MAAM,IAAIjC,UAAWC,EAAQ,SAAUgC,IAExC,IAAMY,EAAwBZ,EAASa,QACtC,MAAM,IAAI9C,UAAWC,EAAQ,+GAAgHgC,EAASa,SAEvJ,IAAMC,EAAsBd,EAASe,SACpC,MAAM,IAAIhD,UAAWC,EAAQ,sGAAuGgC,EAASe,UAO9I,GALAb,KAAKc,OAAS,CACbZ,QAAWP,EAAMO,QACjBG,MAAWV,EAAW,MAAKoB,EAAcpB,EAAMU,OAAU,GACzDE,KAAUZ,EAAU,KAAKqB,EAAMrB,EAAMY,MAAS,IAE1CP,KAAKc,OAAOT,MAAM7B,SAAWwB,KAAKc,OAAOP,KAAK/B,OAClD,MAAM,IAAIC,MAAO,8JAQlB,OANAuB,KAAKiB,SAAWrB,EAChBI,KAAKkB,SAAWrB,EAChBG,KAAKmB,UAAY,CAChBR,OAAUb,EAASa,OACnBE,QAAWf,EAASe,SAEdb,IACR,CAsDAoB,EAAa1B,EAAyB2B,UAAW,SAAS,SAAgBtC,GACzE,IAAIuC,EACA5D,EACAD,EACA8D,EACAC,EACAC,EACAlE,EACAmE,EACAC,EACAC,EACAC,EACAC,EACAnE,EACAoE,EACAC,EACAC,EACAlC,EACAmC,EACArD,EACAM,EACAK,EAGJ,GADA+B,EAAQY,UAAU3D,QACZ4D,EAAerD,GACpB,MAAM,IAAIlB,UAAWC,EAAQ,SAAUiB,IAGxC,GADAgD,EAAMM,EAAUtD,IACVJ,EAAUqB,KAAKiB,SAAU,GAAKc,GACnC,MAAM,IAAIlE,UAAWC,EAAQ,qGAAsGS,EAAMyB,KAAKiB,SAAU,GAAK,QAAUc,IAGxK,IADAN,EAAO,CAAE1C,GACHS,EAAI,EAAGA,EAAI+B,GAEVa,EADNN,EAAMK,UAAW3C,IADMA,IAAM,CAM7B,GADAO,EAAKsC,EAAUP,IACTnD,EAAUqB,KAAKiB,SAAUzB,GAAKO,GACnC,MAAM,IAAIlC,UAAWC,EAAQ,kGAAmG0B,EAAGjB,EAAMyB,KAAKiB,SAAUzB,GAAK,QAAUO,IAGxK0B,EAAKa,KAAMR,EACX,CAED,GAAKtC,EAAI+B,EAAM,EACd,MAAM,IAAI1D,UAAWC,EAAQ,6EAA8E0B,EAAG2C,UAAW3C,KAG1H,GAAKA,IAAM+B,EACV,MAAM,IAAI1D,UAAWC,EAAQ,SAAUqE,UAAWZ,EAAM,KAGzD,GAAK/B,IAAM+B,EAAM,EAAI,CAIpB,GAHAU,GAAM,EACNvE,EAAUyE,UAAWZ,EAAM,IAErBtB,EADNuB,EAAOW,UAAWZ,EAAM,IAEvB,MAAM,IAAI1D,UAAWC,EAAQ,SAAU0D,IAExCF,EAAUa,UAAWZ,EAAM,EAC3B,MAEI,GAAK/B,IAAM+B,EAAM,GAErB,IAAMtB,EADNuB,EAAOW,UAAWZ,EAAM,IAEvB,MAAM,IAAI1D,UAAWC,EAAQ,SAAU0D,SAIpC,GAAKvB,EAAYkC,UAAWZ,EAAM,IACtCC,EAAOW,UAAWZ,EAAM,GACxBD,EAAUa,UAAWZ,EAAM,OAGvB,KAAKtB,EAAYkC,UAAWZ,EAAM,IAOtC,MAAM,IAAI1D,UAAWC,EAAQ,SAAUqE,UAAWZ,EAAM,KANxDU,GAAM,EACNvE,EAAUyE,UAAWZ,EAAM,GAC3BC,EAAOW,UAAWZ,EAAM,EAKxB,CAKD,GAHA1C,GADA+C,EAAMW,EAAUxD,IACRP,OAERjB,EAAOiF,EAAc,GAAIC,GACpBR,IACJP,EAAMpE,EAAUC,EAAMsB,EAAGmB,KAAKkB,SAAUxD,IAEvC,MAAMgE,EA4CR,OAxCmB,OAAdnE,EAAKW,OACTX,EAAKW,KAAOwE,EAAQ7D,IAGrB8C,EAAMgB,EAAmB9D,EAAGtB,EAAKW,MAGjC2D,EAAMe,EAAahB,EAAKD,GAGxBK,EAAMzE,EAAKmB,OAASmE,EAAqBd,EAAK/B,KAAKmB,UAAUR,QAC7DxB,EAAI2D,EAAOjB,EAAK,CACfnD,MAASsD,EACTe,MAASC,EAAUjE,KAKfgD,KADLhC,EAAKkD,EAA2BlB,EAAKC,EAAKhC,KAAKmB,UAAUN,YAGxDlD,EAAMuF,EAAWnD,EAAI6B,EAAKoB,EAAUjE,IACpCoE,EAAQ,CAAEpE,EAAGpB,IACb8D,EAAM,GAAM9D,EACZoE,EAAMhC,GAGPtC,EAAS,CAAE2F,EAAarB,IAGvBG,GAFD1C,EAAIZ,EAAcoB,KAAKc,OAAOP,KAAK/B,OAAQ,EAAGwB,KAAKc,OAAOT,MAAO,EAAG,EAAG,EAAG5C,EAAQ,EAAG,KAC3E,EACLuC,KAAKc,OAAOP,KAAMf,GAElBQ,KAAKc,OAAOZ,QAGjBmD,EAAwBnB,EAAGoB,EAAU7B,EAAM,EAAGtC,GAAK5B,EAAKW,KAAMsD,EAAMF,GAG/D/D,EAAKS,WACTmB,EAAIoE,EAAkB1E,EAAGM,EAAGwC,IAEtBxC,CACR,IA6DAiC,EAAa1B,EAAyB2B,UAAW,UAAU,SAAS8B,EAAQpE,GAC3E,IAAIuC,EACA5D,EACAD,EACA8D,EACAC,EACAjE,EACAkE,EACAK,EACAJ,EACAO,EACAF,EACApE,EACAoC,EACAlB,EACAqD,EACA/C,EACAK,EAGJ,GADA+B,EAAQY,UAAU3D,QACZ4D,EAAerD,GACpB,MAAM,IAAIlB,UAAWC,EAAQ,SAAUiB,IAIxC,GADAgD,EAAMM,EAAUtD,IACVJ,EAAUqB,KAAKiB,SAAU,GAAKc,GACnC,MAAM,IAAIlE,UAAWC,EAAQ,qGAAsGS,EAAMyB,KAAKiB,SAAU,GAAK,QAAUc,IAKxK,IAHAN,EAAO,CAAE1C,GAGHS,EAAI,EAAGA,EAAI+B,GAEVa,EADNN,EAAMK,UAAW3C,IADMA,IAKvBiC,EAAKa,KAAMR,GAGZ,GAAKtC,EAAI,EACR,MAAM,IAAI3B,UAAWC,EAAQ,iFAAkFqE,UAAW,KAG3H,GAAK3C,IAAM+B,EACV,MAAM,IAAI1D,UAAWC,EAAQ,SAAUqE,UAAWZ,EAAM,KAGzD,GAAK/B,IAAM+B,EAAM,EAAI,CAIpB,GAHAU,GAAM,EACNvE,EAAUyE,UAAWZ,EAAM,IAErBtB,EADNuB,EAAOW,UAAWZ,EAAM,IAEvB,MAAM,IAAI1D,UAAWC,EAAQ,SAAU0D,IAExCF,EAAUa,UAAWZ,EAAM,EAC3B,MAEI,GAAK/B,IAAM+B,EAAM,GAErB,IAAMtB,EADNuB,EAAOW,UAAWZ,EAAM,IAEvB,MAAM,IAAI1D,UAAWC,EAAQ,SAAU0D,SAIpC,GAAKvB,EAAYkC,UAAWZ,EAAM,IACtCC,EAAOW,UAAWZ,EAAM,GACxBD,EAAUa,UAAWZ,EAAM,OAGvB,KAAKtB,EAAYkC,UAAWZ,EAAM,IAOtC,MAAM,IAAI1D,UAAWC,EAAQ,SAAUqE,UAAWZ,EAAM,KANxDU,GAAM,EACNvE,EAAUyE,UAAWZ,EAAM,GAC3BC,EAAOW,UAAWZ,EAAM,EAKxB,CAKD,IAHApC,EAAIsC,EAAK+B,MAGHhE,EAAI,EAAGA,EAAIiC,EAAKjD,OAAQgB,IAE7B,GADAO,EAAKsC,EAAUZ,EAAMjC,KACfb,EAAUqB,KAAKiB,SAAUzB,GAAKO,GACnC,MAAM,IAAIlC,UAAWC,EAAQ,kGAAmG0B,EAAGjB,EAAMyB,KAAKiB,SAAUzB,GAAK,QAAUO,IAMzK,GAFAlB,EAAIrB,EAAOuB,GACXxB,EAAOiF,EAAc,GAAIC,GACpBR,IACJP,EAAMpE,EAAUC,EAAMsB,EAAGmB,KAAKkB,SAAUxD,IAEvC,MAAMgE,EA2BR,OAvBmB,OAAdnE,EAAKW,OACTX,EAAKW,KAAOwE,EAAQ7D,IAIhBkD,KADLhC,EAAKkD,EAA2BlB,EAAKM,EAAUlD,GAAKa,KAAKmB,UAAUN,YAIlEsC,EAAQ,CAAEpE,EADVpB,EAAMuF,EAAWnD,EAAIwC,EAAUxD,GAAKiE,EAAUjE,MAE9C0C,EAAM,GAAM9D,EACZoE,EAAMhC,GAGPtC,EAAS,CAAE2F,EAAarB,IAGvBG,GAFD1C,EAAIZ,EAAcoB,KAAKc,OAAOP,KAAK/B,OAAQ,EAAGwB,KAAKc,OAAOT,MAAO,EAAG,EAAG,EAAG5C,EAAQ,EAAG,KAC3E,EACLuC,KAAKc,OAAOP,KAAMf,GAElBQ,KAAKc,OAAOZ,QAGjBmD,EAAwBnB,EAAGoB,EAAU7B,EAAM,EAAGtC,GAAK5B,EAAKW,KAAMsD,EAAMF,GAE7DnC,CACR"}